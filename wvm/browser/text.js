// Contains text constants for the UI.

module.exports = {
	halt: "Halts the VM.",
	prc: "Prints the contents of the register as a character.",
	prd: "Prints the contents of the register as a decimal number.",
	prx: "Prints the contents of the register as a hexadecimal number.",
	prb: "Prints the contents of the register as a binary number.",
	sleep: "Pauses execution for a given number of milliseconds.",

	add: "Adds the values in rs and rt and stores the result in rd.",
	sub: "Subtracts the value in rt from the value in rs and stores the result in rd.",
	mult: "Multiplies the value in rs by the value in rt and stories the upper half in $hi and the lower half in $lo.",
	multu: "Multiplies the value in rs by the value in rt (treating both as unsigned values) and stories the upper half in $hi and the lower half in $lo.",
	sll: "Logically shifts the value in rs to the left by a number of bits equal to the value in rt and stores the result in rd.",
	srl: "Logically shifts the value in rs to the right by a number of bits equal to the value in rt and stores the result in rd.",
	sra: "Arithmetically shifts the value in rs to the left by a number of bits equal to the value in rt and stores the result in rd.",
	mod: "Computes the rt-modulo of rs and stores the result in rd.",

	and: "Computes the bitwise AND of rs and rt and stores the result in rd.",
	nand: "Computes the bitwise NAND of rs and rt and stores the result in rd.",
	nor: "Computes the bitwise NOR of rs and rt and stores the result in rd.",
	not: "Computes the bitwise NOT of rs and stores the result in rd.",
	or: "Computes the bitwise OR of rs and rt and stores the result in rd.",
	xnor: "Computes the bitwise XNOR of rs and rt and stores the result in rd.",
	xor: "Computes the bitwise XOR of rs and rt and stores the result in rd.",
	land: "Computes the logical NAND of rs and rt and stores the result in rd.",
	lnor: "Computes the logical NOR of rs and rt and stores the result in rd.",
	lnot: "Computes the logical NOT of rs and stores the result in rd.",
	lor: "Computes the logical OR of rs and rt and stores the result in rd.",
	lxnor: "Computes the logical XNOR of rs and rt and stores the result in rd.",
	lxor: "Computes the logical XOR of rs and rt and stores the result in rd.",

	addi: "Adds the value in rs and a constant and stores the result in rd.",
	subi: "Subtracts a constant from the value in rs and stores the result in rd.",
	multi: "Multiplies the value in rs by a constant and stories the upper half in $hi and the lower half in $lo.",
	multui: "Multiplies the value in rs by a constant (treating both as unsigned values) and stories the upper half in $hi and the lower half in $lo.",
	slli: "Logically shifts the value in rs to the left by a number of bits equal to imm and stores the result in rd.",
	srli: "Logically shifts the value in rs to the right by a number of bits equal to imm and stores the result in rd.",
	srai: "Arithmetically shifts the value in rs to the right by a number of bits equal to imm and stores the result in rd.",
	modi: "Computes the imm-modulo of rs and stores the result in rd.",

	andi: "Computes the bitwise AND of rs and a constant and stores the result in rd.",
	nandi: "Computes the bitwise NAND of rs and a constant and stores the result in rd.",
	nori: "Computes the bitwise NOR of rs and a constant and stores the result in rd.",
	ori: "Computes the bitwise OR of rs and a constant and stores the result in rd.",
	xnori: "Computes the bitwise XNOR of rs and a constant and stores the result in rd.",
	xori: "Computes the bitwise XOR of rs and a constant and stores the result in rd.",

	lui: "Loads an immediate value into the upper half of the word at rd. The lower half is not affected.",

	cmp: "Compares the value in rs to the value in rt and updates the status register.",
	sl: "If the value in rs is less than the value in rt, rd is set to 1; otherwise, rd is set to 0.",
	sle: "If the value in rs is less than or equal to the value in rt, rd is set to 1; otherwise, rd is set to 0.",
	seq: "If the value in rs is equal to the value in rt, rd is set to 1; otherwise, rd is set to 0.",
	slu: "If the value in rs is less than the value in rt (treating both as unsigned values), rd is set to 1; otherwise, rd is set to 0.",
	sleu: "If the value in rs is less than or equal to the value in rt (treating both as unsigned values), rd is set to 1; otherwise, rd is set to 0.",

	sli: "If the value in rs is less than imm, rd is set to 1; otherwise, rd is set to 0.",
	slei: "If the value in rs is less than or equal to imm, rd is set to 1; otherwise, rd is set to 0.",
	seqi: "If the value in rs is equal to imm, rd is set to 1; otherwise, rd is set to 0.",
	sgi: "If the value in rs is greater than imm, rd is set to 1; otherwise, rd is set to 0.",
	sgei: "If the value in rs is greater than or equal to imm, rd is set to 1; otherwise, rd is set to 0.",
	slui: "If the value in rs is less than imm (treating both as unsigned values), rd is set to 1; otherwise, rd is set to 0.",
	sleui: "If the value in rs is less than or equal to imm (treating both as unsigned values), rd is set to 1; otherwise, rd is set to 0.",
	
	j: "Jumps to the address of a given label or directly to a given address.",
	jc: "Jumps to the address of a given label or directly to a given address, provided the value in rs is nonzero.",

	jr: "Jumps to the address stored in rd.",
	jrc: "Jumps to the address stored in rd, provided the value in rs is nonzero.",
	jrl: "Stores the address of the next instruction in $rt and jumps to the address stored in rd.",
	jrlc: "Stores the address of the next instruction in $rt and jumps to the address stored in rd, provided the value in rs is nonzero.",

	c: "Copies the word beginning at the memory address pointed to by rs into memory beginning at the address pointed to by rd.",
	l: "Loads the word beginning at the memory address pointed to by rs into rd.",
	s: "Stores the value of rs into memory beginning at the address pointed to by rd.",
	cb: "Copies the byte stored at the memory address pointed to by rs into the memory address pointed to by rd.",
	lb: "Loads the byte stored at the memory address pointed to by rs into rd.",
	sb: "Stores the lowest 8 bits of rs into the memory address pointed to by rd.",
	spush: "Copies the word at rs into the stack and adjusts the stack pointer.",
	spop: "Adjusts the stack pointer and copies the word at the stack pointer into rd.",

	li: "Loads the word beginning at address imm into rd.",
	si: "Stores the value of rs into memory beginning at address imm.",
	lbi: "Loads the byte at address imm into rd.",
	sbi: "Stores the lowest 8 bits of rs into memory at address imm.",
	lni: "Copies the word stored in memory at address imm into the memory beginning at the address pointed to by rd.",
	lbni: "Copies the byte stored in memory at address imm into the memory address pointed to by rd.",
	set: "Sets a register to the given immediate value.",

	rit: "Registers an interrupt table. Requires kernel mode.",
	int: "Causes an interrupt.",
	ring: "Sets the ring.",
	ringi: "Sets the ring.",
	time: "Starts a timer. Requires kernel mode.",
	timei: "Starts a timer. Requires kernel mode.",
};
